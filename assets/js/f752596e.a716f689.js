"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2394],{922:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"move-basics/type-reflection","title":"Type Reflection","description":"In programming languages, reflection is the ability of a program to examine and modify its own","source":"@site/../book/move-basics/type-reflection.md","sourceDirName":"move-basics","slug":"/move-basics/type-reflection","permalink":"/docusaurus-test/move-basics/type-reflection","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"bookSidebar","previous":{"title":"5.24. Generics","permalink":"/docusaurus-test/move-basics/generics"},"next":{"title":"5.26. Testing","permalink":"/docusaurus-test/move-basics/testing"}}');var r=t(3420),o=t(5521);const i={},a="Type Reflection",c={},d=[{value:"In practice",id:"in-practice",level:2},{value:"Further Reading",id:"further-reading",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"type-reflection",children:"Type Reflection"})}),"\n",(0,r.jsxs)(n.p,{children:["In programming languages, ",(0,r.jsx)(n.em,{children:"reflection"})," is the ability of a program to examine and modify its own\nstructure and behavior. Move has a limited form of reflection that allows you to inspect the type of\na value at runtime. This is useful when you need to store type information in a homogeneous\ncollection, or when you need to check if a type belongs to a package."]}),"\n",(0,r.jsxs)(n.p,{children:["Type reflection is implemented in the ",(0,r.jsx)(n.a,{href:"/docusaurus-test/move-basics/standard-library",children:"Standard Library"})," module\n",(0,r.jsx)(n.a,{href:"https://docs.sui.io/references/framework/std/type_name",children:(0,r.jsx)(n.code,{children:"std::type_name"})}),". Expressed very roughly, it gives a single function ",(0,r.jsx)(n.code,{children:"get<T>()"}),"\nwhich returns the name of the type ",(0,r.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"in-practice",children:"In practice"}),"\n",(0,r.jsx)(n.p,{children:"The module is straightforward, and operations allowed on the result are limited to getting a string\nrepresentation and extracting the module and address of the type."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-move",metastring:"file=packages/samples/sources/move-basics/type-reflection.move anchor=main",children:'module book::type_reflection;\n\nuse std::ascii::String;\nuse std::type_name::{Self, TypeName};\n\n/// A function that returns the name of the type `T` and its module and address.\npublic fun do_i_know_you<T>(): (String, String, String) {\n    let type_name: TypeName = type_name::get<T>();\n\n    // there\'s a way to borrow\n    let str: &String = type_name.borrow_string();\n\n    let module_name: String = type_name.get_module();\n    let address_str: String = type_name.get_address();\n\n    // and a way to consume the value\n    let str = type_name.into_string();\n\n    (str, module_name, address_str)\n}\n\n#[test_only]\npublic struct MyType {}\n\n#[test]\nfun test_type_reflection() {\n    let (type_name, module_name, _address_str) = do_i_know_you<MyType>();\n\n    //\n    assert!(module_name == b"type_reflection".to_ascii_string());\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://docs.sui.io/references/framework/std/type_name",children:"std::type_name"})," module documentation."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},5521:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(6672);const r={},o=s.createContext(r);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);